#!/usr/bin/python

import sys, os, time, thread, gi
from importlib import import_module
gi.require_version('Gst', '1.0')
from gi.repository import GObject,GLib,Gst
GObject.threads_init()
Gst.init(None)

### Streamer Class to build up Gstreamer pipeline from in to out
class Streamer(object):
        def __init__(self,width,height,framerate,format,input,source,output,dest):
            self.size = 0
            self.playing = False
            self.paused = False
            
            # Start with creating a pipeline from source element
            if input == "appsrc":
                self.input_appsrc(source)
            elif input == "v4l2":
                self.input_v4l2(source)
            
            # Next deal with each format separately and interpret the stream and encoding method to the pipeline
            if format == "h264":
                self.capstring = 'video/x-h264,width='+str(width)+',height='+str(height)+',framerate='+str(framerate)+'/1'
                self.stream_h264()
            elif format == "mjpeg":
                self.capstring = 'image/jpeg,width='+str(width)+',height='+str(height)+',framerate='+str(framerate)+'/1'
                self.stream_mjpeg()
                self.encode_h264()
            
            # Finally connect the requested output to the end of the pipeline
            if output == "file":
                self.output_file(dest)
            elif output == "udp":
                self.output_udp(dest)
            
            self.bus()
            self.start() # need to self start the object for PiCamera method
            

        ### Input methods
        def input_appsrc(self, source):
            print "Attaching input 'appsrc'"
            self.streamer = Gst.Pipeline.new()
            self.source = Gst.ElementFactory.make("appsrc", "source")
            self.streamer.add(self.source)
            self.source.set_property("is-live",True)
        
        
        def input_v4l2(self, source):
            print "Attaching input 'v4l2'"
            if not source:
                source = "/dev/video"
            self.streamer = Gst.Pipeline.new()
            self.source = Gst.ElementFactory.make("v4l2src", "v4l2-source")
            self.streamer.add(self.source)
            self.source.set_property("device", source)


        ### Stream methods
        def stream_h264(self):
            print "Attaching stream 'h264'"
            capsfilter = Gst.ElementFactory.make("capsfilter", "capsfilter")
            capsfilter.set_property('caps', Gst.Caps.from_string(self.capstring))
            self.streamer.add(capsfilter)
            self.source.link(capsfilter)
            parse = Gst.ElementFactory.make("h264parse", "h264parse")
            self.streamer.add(parse)
            capsfilter.link(parse)
            h264pay = Gst.ElementFactory.make("rtph264pay", "h264-payload")
            h264pay.set_property("config-interval", 1)
            h264pay.set_property("pt", 96)
            self.streamer.add(h264pay)
            parse.link(h264pay)
            self.source_attach = h264pay
            self.encode_attach = self.source_attach # fake encode_attach as we don't need to encode, we already have encoded stream

            
        def stream_mjpeg(self):
            print "Attaching stream 'mjpeg'"
            capsfilter = Gst.ElementFactory.make("capsfilter", "capsfilter")
            capsfilter.set_property('caps', Gst.Caps.from_string(self.capstring))
            self.streamer.add(capsfilter)
            self.source.link(capsfilter)
            parse = Gst.ElementFactory.make("jpegparse", "jpegparse")
            self.streamer.add(parse)
            capsfilter.link(parse)
            dec = Gst.ElementFactory.make("jpegdec", "jpegdec")
            self.streamer.add(dec)
            parse.link(dec)
            queue = Gst.ElementFactory.make("queue", "queue")
            self.streamer.add(queue)
            dec.link(queue)
            vconvert = Gst.ElementFactory.make("videoconvert", "videoconvert")
            self.streamer.add(vconvert)
            queue.link(vconvert)
            self.source_attach = vconvert


        ### Encoding methods
        def encode_h264(self):
            print "Attaching encoding 'h264'"
            if Gst.ElementFactory.find("omxh264enc"):
                print "Raspberry hardware encoder detected, using omxh264enc as h264 encoder"
                self.h264enc = Gst.ElementFactory.make("omxh264enc", "raspberry-h264-encode")
            else:
                print "No hardware encoder detected, using software x264 encoder"
                self.h264enc = Gst.ElementFactory.make("x264enc", "x264-encode")
                self.h264enc.set_property('speed-preset', 1)
                self.h264enc.set_property('tune', 0x00000004)
            self.streamer.add(self.h264enc)
            self.source_attach.link(self.h264enc)
            parse = Gst.ElementFactory.make("h264parse", "h264parse")
            self.streamer.add(parse)
            self.h264enc.link(parse)
            h264pay = Gst.ElementFactory.make("rtph264pay", "h264-payload")
            h264pay.set_property("config-interval", 1)
            h264pay.set_property("pt", 96)
            self.streamer.add(h264pay)
            parse.link(h264pay)
            self.encode_attach = h264pay


        ### Output methods
        def output_file(self, dest):
            print "Attaching output 'file'"
            mux = Gst.ElementFactory.make("mpegtsmux", "mux")
            self.streamer.add(mux)
            self.encode_attach.link(mux)
            
            sink = Gst.ElementFactory.make("filesink", "sink")
            sink.set_property("location", dest)
            self.streamer.add(sink)
            mux.link(sink)

        
        def output_udp(self, dest):
            if not dest:
                print "UDP destination must be set"
                return
            print "Attaching output 'udp'"
            sink = Gst.ElementFactory.make("udpsink", "udpsink")
            sink.set_property("host", dest)
            sink.set_property("port", 5000)
            sink.set_property("sync", False)
            self.streamer.add(sink)
            self.encode_attach.link(sink)

        
        ### Misc methods (glib introspection)
        def on_message(self, bus, message):
            t = message.type
            if t == Gst.MessageType.EOS:
                self.streamer.set_state(Gst.State.NULL)
                self.playing = False
            elif t == Gst.MessageType.ERROR:
                self.streamer.set_state(Gst.State.NULL)
                err, debug = message.parse_error()
                print "Error: %s" % err, debug
                self.playing = False

            
        def bus(self):
            bus = self.streamer.get_bus()
            bus.add_signal_watch()
            bus.connect("message", self.on_message)


        ### Action methods
        def start(self):
            self.streamer.set_state(Gst.State.PLAYING)
            self.playing = True


        def write(self,s):
            gstbuff = Gst.Buffer.new_wrapped(s)
            ret = self.source.emit("push-buffer",gstbuff)


        def stop(self):
            self.streamer.set_state(Gst.State.READY)
            self.playing = False


        def flush(self):
            self.stop()

            
### RaspberryCam Class, a clever way of using the Streamer class but proprietary to raspberry so will probably deprecate in favour of generic v4l2 method
class RaspberryCam(object):
    def __init__(self):
        picamera = import_module('picamera')
        picamera.array = import_module('picamera.array')
        self.resolution = (1280,720)
        self.width = 1280
        self.height = 720
        self.bitrate = 5000000
        self.format = "mjpeg" # mjpeg or h264
        self.framerate = 30
        self.rotation = 180
        
        self.input = "appsrc"
        self.source = ""
        
        self.output = "udp" # file or udp
        self.dest = "192.168.1.65" # filename or ip address
        
        self.camera = picamera.PiCamera()
        self.camera.resolution = self.resolution
        self.camera.framerate = self.framerate

    def start(self):
        self.camera.start_recording(Streamer(self.width,self.height,self.framerate,self.format,self.input,self.source,self.output,self.dest),format=self.format,bitrate=self.bitrate)

    def record(self,duration):
        self.camera.wait_recording(duration)

    def stop(self):
        self.camera.stop_recording()

    def close(self):
        self.camera.close()


print "Starting fpv"

stream = Streamer(1280,720,30,'mjpeg','v4l2','/dev/video0','udp','192.168.1.65') # Works with both raspberry and ocam
#stream = Streamer(1280,720,49,'h264','v4l2','/dev/video0','file','/var/tmp/test.ts')
thread.start_new_thread(stream.start, ())

t_end = time.time() + 60
while time.time() < t_end: 
    pass

print "Stopped fpv"



## this works for ocam
# gst-launch-1.0 -vvv v4l2src ! 'image/jpeg,width=1280,height=720,framerate=30/1' ! jpegparse ! jpegdec ! queue ! videoconvert ! x264enc ! mpegtsmux ! filesink location='/var/tmp/test.ts'
# gst-launch-1.0 -vvv v4l2src ! 'image/jpeg,width=1280,height=720,framerate=30/1' ! filesink location='/var/tmp/test.ts'
## raspicam
# gst-launch-1.0 -vvv v4l2src device=/dev/video0 ! 'video/x-h264,width=640,height=480,framerate=30/1' ! h264parse ! rtph264pay config-interval=1 pt=96 ! udpsink host=192.168.1.65 port=5000
# gst-launch-1.0 -vvv v4l2src device=/dev/video0 ! 'video/x-raw,width=1280,height=720,framerate=30/1' ! omxh264enc ! h264parse ! rtph264pay config-interval=1 pt=96 ! udpsink host=192.168.1.65 port=5000 sync=false
# gst-launch-1.0 -vvv v4l2src device=/dev/video0 ! 'image/jpeg,width=1280,height=720,framerate=30/1' ! jpegparse ! jpegdec ! queue ! videoconvert ! x264enc ! h264parse ! rtph264pay config-interval=1 pt=96 ! udpsink host=192.168.1.65 port=5000 sync=false
"""
# Deprecated RaspberryCam method
cam = RaspberryCam()
cam.start()
cam.record(15)
cam.stop()
cam.close()
"""
